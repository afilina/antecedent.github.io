<!DOCTYPE html>
<html>
<head>
    <title>A Time and Place for Monkey Patching</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="patchwork/style.css" type="text/css">
    <link rel="alternate" href="patchwork/blog/atom.xml" type="application/atom+xml">    
    <script type="text/javascript">
    
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-20483190-1']);
      _gaq.push(['_trackPageview']);
    
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>    
</head>
<body>

<div id="main">

<h2 class="with-border">A Time and Place for Monkey Patching</h2>

<h3>Background</h3>

<p>Consider the function below, written in PHP 5.4:</p>

<pre><span class="keyword">function</span> deleteOldPosts<span class="noise">(</span><span class="noise">)</span>
<span class="noise">{</span>
    $threshold = strtotime<span class="noise">(</span><span class="string">&quot;-1 year&quot;</span><span class="noise">)</span>;
    <span class="comment"># Fetch all posts older than $threshold from the database</span>
    $oldPosts = Post<span class="noise">::</span>findAll<span class="noise">(</span><span class="noise">[</span><span class="string">&quot;timestamp&quot;</span> =&gt; <span class="noise">[</span><span class="string">&quot;&lt;&quot;</span> =&gt; $threshold<span class="noise">]</span><span class="noise">]</span><span class="noise">)</span>;
    <span class="keyword">foreach</span> <span class="noise">(</span>$oldPosts <span class="keyword">as</span> $oldPost<span class="noise">)</span> <span class="noise">{</span>
        $oldPost<span class="noise">-&gt;</span>delete<span class="noise">(</span><span class="noise">)</span>;
    <span class="noise">}</span>
<span class="noise">}</span>
</pre>

<h3>The Problem</h3>

<p>For anyone with some experience in unit testing, this piece of code will
 seem untestable.</p>

<p>Why is that, you might ask? The nature of unit testing is to verify the behavior
 of separate components &ndash; for example, functions &ndash;
 <em>in isolation</em>. In our case, we would want to isolate our code from the
  <kbd>strtotime()</kbd>  function, which involves fetching the current time from the 
  system clock, and the data model, represented by the <kbd>Post</kbd> class. 
  Inside a unit test, we would want to replace them with <em>test doubles</em> 
  &ndash; their fake counterparts that behave in a preset and predictable manner:</p>

<pre><span class="keyword">function</span> fakeStrToTime<span class="noise">(</span>$str<span class="noise">)</span>
<span class="noise">{</span>
    assert<span class="noise">(</span>$str === <span class="string">&quot;-1 year&quot;</span><span class="noise">)</span>;
    <span class="keyword">return</span> 123;
<span class="noise">}</span>;

<span class="keyword">class</span> FakePost
<span class="noise">{</span>
    <span class="keyword">static</span> $deleteCount = 0;

    <span class="keyword">function</span> delete<span class="noise">(</span><span class="noise">)</span>
    <span class="noise">{</span>
        self<span class="noise">::</span>$deleteCount++;
    <span class="noise">}</span>
	
    <span class="keyword">static</span> <span class="keyword">function</span> findAll<span class="noise">(</span>$criteria<span class="noise">)</span>
    <span class="noise">{</span>
        assert<span class="noise">(</span>$criteria === <span class="noise">[</span><span class="string">&quot;timestamp&quot;</span> =&gt; <span class="noise">[</span><span class="string">&quot;&lt;&quot;</span> =&gt; 123<span class="noise">]</span><span class="noise">]</span><span class="noise">)</span>;
        <span class="keyword">return</span> <span class="noise">[</span><span class="keyword">new</span> FakePost, <span class="keyword">new</span> FakePost<span class="noise">]</span>;
    <span class="noise">}</span>
<span class="noise">}</span></pre>

<p>However, we see no way of plugging these test doubles into 
<kbd>deleteOldPosts()</kbd>. We simply can't tell the function to use a different
implementation of <kbd>Post::findAll()</kbd> or <kbd>strtotime()</kbd>. They are
essentially <em>hardcoded dependencies</em>, which are invariably a major obstacle
on the way to testability.</p>

<h3>A Solution by Refactoring</h3>

<p>Being a dynamic language, PHP supports variable functions and variable class names, 
which provide us with a 
simple and elegant way of making our dependencies easily replaceable:</p>

<pre><span class="keyword">function</span> deleteOldPosts<span class="noise">(</span><span style="text-decoration: underline;">$strtotime = <span class="string">&quot;strtotime&quot;</span>, $postModel = <span class="string">&quot;Post&quot;</span></span><span class="noise">)</span>
<span class="noise">{</span>
    $threshold = <span style="text-decoration: underline;">$strtotime</span><span class="noise">(</span><span class="string">&quot;-1 year&quot;</span><span class="noise">)</span>;
    $oldPosts = <span style="text-decoration: underline;">$postModel</span><span class="noise">::</span>findAll<span class="noise">(</span><span class="noise">[</span><span class="string">&quot;timestamp&quot;</span> =&gt; <span class="noise">[</span><span class="string">&quot;&lt;&quot;</span> =&gt; $threshold<span class="noise">]</span><span class="noise">]</span><span class="noise">)</span>;
    <span class="keyword">foreach</span> <span class="noise">(</span>$oldPosts <span class="keyword">as</span> $oldPost<span class="noise">)</span> <span class="noise">{</span>
        $oldPost<span class="noise">-&gt;</span>delete<span class="noise">(</span><span class="noise">)</span>;
    <span class="noise">}</span>
<span class="noise">}</span>
</pre>

<p>With this modification, which could be called a simple form of <a href="http://en.wikipedia.org/Dependency_injection">dependency 
injection</a>, plugging our test doubles into the function becomes as easy as passing
 their names as arguments:</p>

<pre>deleteOldPosts<span class="noise">(</span><span class="string">&quot;fakeStrToTime&quot;</span>, <span class="string">&quot;FakePost&quot;</span><span class="noise">)</span>;
assert<span class="noise">(</span>FakePost<span class="noise">::</span>$deleteCount === 2<span class="noise">)</span>;</pre>

<p>So, if you have code made untestable by hardcoded function and static method calls
like in our first example, and refactoring it like we did above is a feasible option,
then it is really the way to go. It's relatively simple, and it preserves compatibility 
with the original API, while providing both testability and additional flexibility.</p>

<p>Also
note that passing the dependencies as arguments isn't the only option. If you are
dealing with a method instead of a function, you can 
<a href="https://gist.github.com/3104395">use a special <kbd>getDependencies()</kbd> method</a> or field
for that as well.</p>

<p>However, it's also possible that this kind of refactoring may not be an option for you.
For example, you might have a large collection of old legacy code that is untestable,
long forgotten, yet working. In such cases, <em>monkey patching</em> might prove to 
be a feasible
alternative.</p>

<h3>A Solution by Monkey Patching</h3>

<p>In most usages, monkey patching means <em>redefining</em> functions, methods and classes
at runtime. This technique is something of a stranger to the PHP universe, mainly because PHP lacks
native support for it, unlike
other dynamic languages such as Ruby or Python.</p>

<p>For example, the below code will not work:</p>

<pre><span class="comment"># Error: strtotime is already defined in the PHP standard library!
</span>
<span class="keyword">function</span> strtotime<span class="noise">(</span>$str<span class="noise">)</span>
<span class="noise">{</span>
    <span class="keyword">return</span> 123;
<span class="noise">}</span></pre>

<p>Nevertheless, things like this aren't entirely impossible. Function and method redefinition
has been implemented in the 
<a href="http://php.net/manual/en/book.runkit.php">Runkit</a> and 
<a href="https://github.com/sebastianbergmann/php-test-helpers/">php-test-helpers</a> core extensions.</p>
 
<p>This is how we would replace our dependencies with test doubles using Runkit:</p>

<pre>runkit_function_rename<span class="noise">(</span><span class="string">&quot;strtotime&quot;</span>, <span class="string">&quot;strtotime_backup&quot;</span><span class="noise">)</span>;
runkit_function_rename<span class="noise">(</span><span class="string">&quot;fakeStrToTime&quot;</span>, <span class="string">&quot;strtotime&quot;</span><span class="noise">)</span>;

runkit_method_rename<span class="noise">(</span><span class="string">&quot;Post&quot;</span>, <span class="string">&quot;findAll&quot;</span>, <span class="string">&quot;findAll_backup&quot;</span><span class="noise">)</span>;
runkit_method_copy<span class="noise">(</span><span class="string">&quot;FakePost&quot;</span>, <span class="string">&quot;findAll&quot;</span>, <span class="string">&quot;Post&quot;</span><span class="noise">)</span>;</pre>

<p>After the above code has been run, our original <kbd>deleteOldPosts()</kbd> function will 
use the test doubles instead of the real implementations of <kbd>strtotime()</kbd> and 
<kbd>Post::findAll()</kbd>, without requiring any modifications to the source code.</p>

<p>Later, we could undo the replacement using the same Runkit's functions we used above.</p>

<h3>Other Implementations of Monkey Patching</h3>

<p>A library of mine, called <a href="patchwork">Patchwork</a>, also implements monkey
patching in PHP. A unique feature of this library is that it is written in pure PHP 5.3
code and requires no core extensions like Runkit to work. However, it is only capable
of redefining <em>user-defined</em> functions and methods and not internal ones like
<kbd>strtotime()</kbd>.</p>

<p>Another <a href="http://till.klampaeckel.de/blog/archives/105-Monkey-patching-in-PHP.html">interesting method</a>
utilizes namespace resolution to achieve monkey patching functionality in PHP 5.3 and newer.
Unfortunately, it is only applicable in a limited range of situations.</p>

<h3>A Final Word</h3>

<p>So, we've demonstrated how code that is conventionally considered unsuitable for unit testing
can be tested unchanged with the help of certain tools. However, as far as conventional testability continues to coincide with flexibility, 
I personally encourage you to write code that is both flexible and testable.</p>

<div class="blog-post-end-box">
<p>This blog post was written by <a href="http://github.com/antecendent">Ignas Rudaitis</a>
 on July 13, 2012.</p>
<p>If you have an opinion you want to express or a question to ask regarding it, please
consider leaving a comment below. Thank you!</p>
</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = 'antecedentgithub';
            var disqus_identifier = '/a-time-and-place-for-monkey-patching.html';
            var disqus_url = 'http://antecedent.github.com/a-time-and-place-for-monkey-patching.html';
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>        
    </div>
</body>
</html>